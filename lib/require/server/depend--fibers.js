/*** Generated by streamline fibers 0.1.0 - DO NOT EDIT ***/var fstreamline__ = require("streamline/lib/fibers/runtime"); (fstreamline__.create(function(_) {var _loadFile_ = fstreamline__.create(_loadFile), _extendPath_ = fstreamline__.create(_extendPath), _directDependencies_ = fstreamline__.create(_directDependencies), _missingDependencies_ = fstreamline__.create(_missingDependencies); "use strict";
//streamline.options = { "lines" : "preserve" }
// Analyzes require dependencies
var fs = require('fs');
var fspath = require('path');
var uuid = require('streamline/lib/util//uuid');
var flows = require('streamline/lib/util/flows');
var each = flows.each;

var dependencies = {};

var commentsRE = /(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(\/\/.*)/g;
var requireRE = /require\s*\(('|")([\w\W]*?)('|")\)/mg;

var funnel = flows.funnel(1);

function _exists(callback, path) {
	fspath.exists(path, function(result) {
		return callback(null, result);
	});
}
function _normalize(path) {
	return path.replace(/\\/g, '/');
}

var modulesDir = _normalize(__dirname).split('/');
modulesDir = modulesDir.slice(0, modulesDir.length - 4).join('/');

function _combine(path, rel) {
	var cut = path.lastIndexOf('/');
	if (cut <= 0)
		throw new Error("too many parent dirs" + rel);
	path = path.substring(0, cut);
	while (rel.indexOf('./.') == 0) // get rid of leading ./. and ./..
		rel = rel.substring(2);
	if (rel.indexOf('../') == 0)
		return _combine(path, rel.substring(1));
	if (rel.indexOf('./') != 0)
		return modulesDir + "/" + rel;
	return path + rel.substring(1);
}

var _etag = uuid.generate();
var _watched = {};

function _watcher(stats) {
	//console.log("WATCHER!")
	funnel(null, function() {
		// one of the files changed: regenerate etag and reset cache
		_etag = uuid.generate();
		// unwatch all files because list may change
		Object.keys(_watched).forEach( function(path) {
			fs.unwatchFile(path);
		});
		_watched = {};
		dependencies = {};
	});
	//console.log("WATCHER DONE!")
}

exports.etag = function() {
	return "" + _etag;
}
function _watch(file) {
	if (!_watched[file]) {
		_watched[file] = true;
		//fs.watchFile(file, _watcher);
	}
}

function _loadFile(_, path) {
	var js = path + ".js";
	var js_ = path + "_.js";
	if (fstreamline__.invoke(null, _exists, [_, js_], 0)) {
		_watch(js_);
		return fstreamline__.invoke(require("streamline/lib/compiler/compile"), "loadFile", [_, js], 0);
	} else if (fstreamline__.invoke(null, _exists, [_, js], 0)) {
		_watch(js);
		return fstreamline__.invoke(fs, "readFile", [js, "utf8", _], 2);
	} else
		throw new Error("invalid require path: " + path);
}

function _extendPath(_, path) {
	if (!fstreamline__.invoke(null, _exists, [_, path + ".js"], 0) && fstreamline__.invoke(null, _exists, [_, path], 0) && fstreamline__.invoke(fs, "stat", [path, _], 1).isDirectory()) {
		// should read package.json here -- see later
		if (fstreamline__.invoke(null, _exists, [_, path + "/main.js"], 0))
			return path + "/main";
		else if (fstreamline__.invoke(null, _exists, [_, path + "/index.js"], 0))
			return path + "/index";
	}
	return path;
}

// Returns all the dependencies of a given js file
// Can be used to build a dependency graph
function _directDependencies(_, path) {
	if (dependencies[path])
		return dependencies[path];
	var result = [];
	dependencies[path] = result;
	var str = fstreamline__.invoke(null, _loadFile_, [_, path], 0);
	str = str.replace(commentsRE, "");
	var match;
	while (match = requireRE.exec(str))
		result.push(_combine(path, match[2]));
	return result;
}

// Returns all the dependencies that we reach from path (recursively) but
// the we don't reach from any of the known paths (recursively too).
// Used to return require lists to the client
function _missingDependencies(_, path, known) {var _explore_ = fstreamline__.create(_explore);
	var knownMap = {};
	known.forEach( function(key) {
		knownMap[key] = true;
	});
	function _explore(_, path, missingMap) {
		path = fstreamline__.invoke(null, _extendPath_, [_, path], 0);
		if (knownMap[path])
			return;
		if (missingMap)
			missingMap[path] = true;
		knownMap[path] = true;
		var dependencies = fstreamline__.invoke(null, _directDependencies_, [_, path], 0);
		fstreamline__.invoke(null, each, [_, dependencies, fstreamline__.create(function(_, dependency) {
			fstreamline__.invoke(null, _explore_, [_, dependency, missingMap], 0);
		}, 0)], 0);
	}

	var missingMap = {};
	// first explore known path, to fill knownMap with all their dependencies
	fstreamline__.invoke(null, each, [_, known, fstreamline__.create(function(_, cur) {
		fstreamline__.invoke(null, _explore_, [_, cur, null], 0);
	}, 0)], 0);
	// then fill missing map
	fstreamline__.invoke(null, _explore_, [_, path, missingMap], 0);
	return Object.keys(missingMap);
}

exports.directDependencies = fstreamline__.create(function(_, path) {
	return fstreamline__.invoke(null, funnel, [_, fstreamline__.create(function(_) {
		return fstreamline__.invoke(null, _directDependencies_, [_, path], 0);
	}, 0)], 0)
}, 0)
exports.missingDependencies = fstreamline__.create(function(_, path, known) {
	return fstreamline__.invoke(null, funnel, [_, fstreamline__.create(function(_) {
		return fstreamline__.invoke(null, _missingDependencies_, [_, path, known], 0);
	}, 0)], 0)
}, 0)

}, 0).call(this, function(err) {
  if (err) throw err;
}));