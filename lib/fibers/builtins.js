/*** Generated by streamline fibers 0.2.4 - DO NOT EDIT ***/var fstreamline__ = require("streamline/lib/fibers/runtime"); (fstreamline__.create(function(_) { /**
 * Copyright (c) 2012 Bruno Jouhier <bruno.jouhier@sage.com>
 * MIT License
 */
/// !doc
/// 
/// # streamline built-ins
///  
(function() {
	"use strict";

	/// * `array.forEach_(_, fn[, thisObj])`  
	///   `fn` is called as `fn(_, elt, i)`.
	Array.prototype.forEach_ = fstreamline__.create(function(_, fn, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var len = this.length;
		for (var i = 0; i < len; i++)
			fstreamline__.invoke(fn, "call", [thisObj, _, this[i], i], 1)
		return this;
	}, 0)
	/// * `result = array.map_(_, fn[, thisObj])`  
	///   `fn` is called as `fn(_, elt, i)`.
	Array.prototype.map_ = fstreamline__.create(function(_, fn, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var result = [];
		var len = this.length;
		for (var i = 0; i < len; i++)
			result[i] = fstreamline__.invoke(fn, "call", [thisObj, _, this[i], i], 1);
		return result;
	}, 0)
	/// * `result = array.filter_(_, fn[, thisObj])`  
	///   `fn` is called as `fn(_, elt)`.
	Array.prototype.filter_ = fstreamline__.create(function(_, fn, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var result = [];
		var len = this.length;
		for (var i = 0; i < len; i++) {
			var elt = this[i];
			if (fstreamline__.invoke(fn, "call", [thisObj, _, elt], 1))
				result.push(elt)
		}
		return result;
	}, 0)
	/// * `bool = array.every_(_, fn[, thisObj])`  
	///   `fn` is called as `fn(_, elt)`.
	Array.prototype.every_ = fstreamline__.create(function(_, fn, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var len = this.length;
		for (var i = 0; i < len; i++) {
			if (!fstreamline__.invoke(fn, "call", [thisObj, _, this[i]], 1))
				return false;
		}
		return true;
	}, 0)
	/// * `bool = array.some_(_, fn[, thisObj])`  
	///   `fn` is called as `fn(_, elt)`.
	Array.prototype.some_ = fstreamline__.create(function(_, fn, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var len = this.length;
		for (var i = 0; i < len; i++) {
			if (fstreamline__.invoke(fn, "call", [thisObj, _, this[i]], 1))
				return true;
		}
		return false;
	}, 0)
	/// * `result = array.reduce_(_, array, fn, val)`  
	///   `fn` is called as `val = fn(_, val, elt, i, array)`.
	Array.prototype.reduce_ = fstreamline__.create(function(_, fn, v, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var len = this.length;
		for (var i = 0; i < len; i++) {
			v = fstreamline__.invoke(fn, "call", [thisObj, _, v, this[i], i, this], 1);
		}
		return v;
	}, 0)
	/// * `result = flows.reduceRight(_, array, fn, val, [thisObj])`  
	///   reduces from end to start by applying `fn` to each element.  
	///   `fn` is called as `val = fn(_, val, elt, i, array)`.
	Array.prototype.reduceRight_ = fstreamline__.create(function(_, fn, v, thisObj) {
		thisObj = thisObj !== undefined ? thisObj : this;
		var len = this.length;
		for (var i = len - 1; i >= 0; i--) {
			v = fstreamline__.invoke(fn, "call", [thisObj, _, v, this[i], i, this], 1);
		}
		return v;
	}, 0)
	
	/// * `array = flows.sort(_, array, compare, [beg], [end])`  
	///   `compare` is called as `cmp = compare(_, elt1, elt2)`
	///   Note: this function _changes_ the original array (and returns it)
	Array.prototype.sort_ = fstreamline__.create(function(_, compare, beg, end){var _qsort_ = fstreamline__.create(_qsort);
		var array = this;
		beg = beg || 0;
		end = end == null ? array.length - 1 : end;
		
		function _qsort(_, beg, end){
			if (beg >= end) 
				return;
			
			if (end == beg + 1) {
				if (fstreamline__.invoke(null, compare, [_, array[beg], array[end]], 0) > 0) {
					var tmp = array[beg];
					array[beg] = array[end];
					array[end] = tmp;
				}
				return;
			}
			
			var mid = Math.floor((beg + end) / 2);
			var o = array[mid];
			var nbeg = beg;
			var nend = end;
			
			while (nbeg <= nend) {
				while (nbeg < end && fstreamline__.invoke(null, compare, [_, array[nbeg], o], 0) < 0) 
					nbeg++;
				
				while (beg < nend && fstreamline__.invoke(null, compare, [_, o, array[nend]], 0) < 0) 
					nend--;
				
				if (nbeg <= nend) {
					var tmp = array[nbeg];
					array[nbeg] = array[nend];
					array[nend] = tmp;
					nbeg++;
					nend--;
				}
			}
			
			if (nbeg < end) 
				_qsort(_, nbeg, end);
			if (beg < nend) 
				_qsort(_, beg, nend);
		}
		_qsort(_, beg, end);
		return array;
	}, 0)

	/// * `result = fn.apply_(_, thisObj, args, [index])`  
	///   Helper to apply `Function.apply` to streamline functions.  
	///   Equivalent to `result = fn.apply(thisObj, argsWith_)` where `argsWith_` is 
	///   a modified argument list in which the callback has been inserted at `index` 
	///   (at the end of the argument list if `index` is not specified).
	Function.prototype.apply_ = function(callback, thisObj, args, index) {
		Array.prototype.splice.call(args, index != null ? index : args.length, 0, callback);
		return this.apply(thisObj, args);
	}
})();

}, 0).call(this, function(err) {
  if (err) throw err;
}));