/*** Generated by streamline fibers 0.1.0 - DO NOT EDIT ***/var fstreamline__ = require("streamline/lib/fibers/runtime"); (fstreamline__.create(function(_) {var _mkdir_ = fstreamline__.create(_mkdir), mtime_ = fstreamline__.create(mtime); //streamline.options = { "lines" : "preserve" }
"use strict";

/// !doc
/// 
/// # streamline/lib/compiler/compile
///  
/// Streamline compiler and file loader
/// 
var fs = require("fs");
var fspath = require("path");

function _exists(callback, fname) {
	fspath.exists(fname, function(result) {
		callback(null, result);
	})
}

function _mkdir(dir, mode, _) {
	var p = fspath.dirname(dir);
	if (!fstreamline__.invoke(null, _exists, [p, _], 1))
		fstreamline__.invoke(null, _mkdir_, [p, mode, _], 2);
	fstreamline__.invoke(fs, "mkdir", [dir, mode, _], 2);
}

function mtime(_, fname) {
	return fstreamline__.invoke(null, _exists, [_, fname], 0) ? fstreamline__.invoke(fs, "stat", [fname, _], 1).mtime : 0;
}

function _getTransform(options) {
	if (options.fibers) { 
		// req variable prevents client side require from getting it as a dependency
		var req = require;
		return req("../fibers/transform");
	}
	else {
		return require("./transform");
	}
}

function _banner(version){
	// important: no newline, to support lines-preserve option!
	return "/*** Generated by streamline " + version + " - DO NOT EDIT ***/";
}

function _extend(obj, other){
	for (var i in other) {
		obj[i] = other[i];
	}
	return obj;
}

function _transform(transform, source, options) {
	var sourceOptions = /streamline\.options\s*=\s*(\{.*\})/.exec(source);
	if (sourceOptions) {
		_extend(options, JSON.parse(sourceOptions[1]));
	}
	source = source.replace(/\r\n/g, "\n");
	options.source = source;
	options.callback = options.callback || "_";
	options.lines = options.lines || "mark";
	return transform.transform(source, options);
}

function parseShebang(content) {
	if (content[0] === '#' && content[1] === '!') {
		var n = content.indexOf("\n");
		var le = "\n";
		if (n != -1) {
			var shebang = content.substr(0, n);
			if (shebang[shebang.length-1] == "\r") {
				le = "\r\n";
				shebang = shebang.substr(0, shebang.length-1);
			}
			content = content.substr(n+1);
			return [shebang, content, le];
		}
	}
	return ['', content, ''];
}
/// * `script = compile.loadFile(_, path, options)`  
///   Loads Javascript file and transforms it if necessary.  
///   Returns the transformed source.  
///   If `path` is `foo_.js`, the source is transformed and the result
///   is *not* saved to disk.  
///   If `path` is `foo.js` and if a `foo_.js` file exists,
///   `foo_.js` is transformed if necessary and saved as `foo.js`.  
///   If `path` is `foo.js` and `foo_.js` does not exist, the contents
///   of `foo.js` is returned.  
///   `options` is a set of options passed to the transformation engine.  
///   If `options.force` is set, `foo_.js` is transformed even if 
///   `foo.js` is more recent.
exports.loadFile = fstreamline__.create(function(_, path, options) {
	options = _extend({}, options || {});
	
	var ext = fspath.extname(path);
	var basename = fspath.basename(path, ext);
	var dirname = fspath.dirname(path);
	if (ext !== '.js') return;
	
	var mtimejs, mtimejs_;
	var dontSave = basename[basename.length - 1] == '_';
	var jsbase = dontSave ? basename.substr(0, basename.length -1)  : basename;
	var js  = dirname + '/' + jsbase + ext;
	var js_ = dirname + '/' + jsbase + '_' + ext;
	var fiberjs = dirname + '/' + jsbase + '--fibers' + ext;
	if (options.fibers && (mtimejs = fstreamline__.invoke(null, mtime_, [_, fiberjs], 0))) {
		js = fiberjs;
	}
	else {
		mtimejs = fstreamline__.invoke(null, mtime_, [_, js], 0);
	}
	mtimejs_ = fstreamline__.invoke(null, mtime_, [_, js_], 0);
	options.lines = options.lines || (dontSave ? "preserve" : "mark");

	var transform = _getTransform(options);
	var banner = _banner(transform.version);
	if (mtimejs_) {
		options.sourceName = js_;
		var content = fstreamline__.invoke(fs, "readFile", [js_, 'utf8', _], 2);
		var shebangparse = parseShebang(content);
		var shebang = shebangparse[0];
		var le      = shebangparse[2];
		content     = shebangparse[1];
		
		banner = shebang + le + banner;
		var transformed = mtimejs && fstreamline__.invoke(fs, "readFile", [js, 'utf8', _], 2);
		if (transformed 
			&& mtimejs_ < mtimejs 
			&& transformed.substring(0, banner.length) == banner
			&& !options.force) {
			return transformed;
		}
		if (options.verbose) {
			console.log("streamline: transforming: " + js_ + " to " + js)
		}
		var transformed = shebang + banner + _transform(transform, content, options);
		if (options.action === 'compile' || !dontSave) {
			// try/catch because write will fail if file was installed globally (npm -g)
			try { 
				fs.writeFile(js, transformed, 'utf8');
			}
			catch (ex) {
			}
		}
		return transformed;
	}
	else {
		options.sourceName = js;
		var content = fstreamline__.invoke(fs, "readFile", [js, 'utf8', _], 2);
		if (options.compileAnyways) {
			// we don't care about shebang here, but keep line ending if it had a shebang for line counts
			var shebangparse = parseShebang(content);
			var shebang = shebangparse[0];
			content     = shebangparse[2] + shebangparse[1];
			return transform.transform(content, options);
		} else {
			return content;
		}
	}
}, 0)

function mtimeSync(fname) {
	try {
		return fs.statSync(fname).mtime;
	}
	catch (ex) {
		return 0;
	}
}

/// * `script = compile.transformModule(path, options)`  
///   Synchronous version of `compile.loadFile`.  
///   Used by `require` logic.
exports.transformModule = function(content, path, options) {
	options = _extend({}, options || {});
	
	var ext = fspath.extname(path);
	var basename = fspath.basename(path, ext);
	var dirname = fspath.dirname(path);

	var mtimejs, mtimejs_;
	var dontSave = basename[basename.length - 1] == '_';
	var jsbase = dontSave ? basename.substr(0, basename.length -1)  : basename;
	var js  = dirname + '/' + jsbase + ext;
	var js_ = dirname + '/' + jsbase + '_' + ext;
	var fiberjs = dirname + '/' + jsbase + '--fibers' + ext;
	if (options.fibers && (mtimejs = mtimeSync(fiberjs))) {
		js = fiberjs;
	}
	else {
		mtimejs = mtimeSync(js);
	}
	mtimejs_ = mtimeSync(js_);
	options.lines = options.lines || (dontSave ? "preserve" : "mark");

	var transform = _getTransform(options);
	var banner = _banner(transform.version);
		
	if (mtimejs_) {
		options.sourceName = js_;
		if (!dontSave) // reload content from js_ file.
			content = fs.readFileSync(js_, 'utf8');
		var shebangparse = parseShebang(content);
		var shebang = shebangparse[0];
		var le      = shebangparse[2];
		content     = shebangparse[1];
		
		banner = shebang + le + banner;
		var transformed = mtimejs && fs.readFileSync(js, 'utf8');
		if (transformed 
			&& mtimejs_ < mtimejs 
			&& transformed.substring(0, banner.length) == banner
			&& !options.force)
			return transformed;
		if (options.verbose)
			console.log("streamline: transforming: " + js_)
		var transformed = banner + _transform(transform, content, options);
		if (!dontSave) {
			// try/catch because write will fail if file was installed globally (npm -g)
			try {
				fs.writeFileSync(js, transformed, 'utf8');
			}
			catch (ex) {
			}
		}
		return transformed;
	}
	else {
		options.sourceName = path;
		if (options.compileAnyways) {
			// we don't care about shebang here, but keep line ending if it had a shebang for line counts
			var shebangparse = parseShebang(content);
			var shebang = shebangparse[0];
			content     = shebangparse[2] + shebangparse[1];
			return transform.transform(content, options);
		} else {
			return content;
		}
	}
}

/// * `compile.compile(_, paths, options)`  
///   Compiles streamline source files in `paths`.  
///   Generates a `foo.js` file for each `foo_.js` file found in `paths`.
///   `paths` may be a list of files or a list of directories which
///   will be traversed recursively.  
///   `options`  is a set of options for the `transform` operation.
exports.compile = fstreamline__.create(function(_, paths, options) {var _compile_ = fstreamline__.create(_compile);
	// require flows after register so that flows module gets recompiled automatically
	var flows = require('../util/flows');
	function _compile(_, path, options) {
		var stat = fstreamline__.invoke(fs, "stat", [path, _], 1);
		if (stat.isDirectory()) {
			fstreamline__.invoke(flows, "each", [_, fstreamline__.invoke(fs, "readdir", [path, _], 1), fstreamline__.create(function(_, f) {
				fstreamline__.invoke(null, _compile_, [_, path + "/" + f, options], 0)
			}, 0)], 0);
		} else if (stat.isFile()) {
			try {
				fstreamline__.invoke(exports, "loadFile", [_, path, options], 0);
			} catch (ex) {
				console.error(ex.message);
				failed++;
			}
		}
		// else ignore
	}

	var failed = 0;
	options = options || {};
	var transform = _getTransform(options);
	if (options.verbose)
		console.log("transform version: " + transform.version)
	if (!paths || paths.length == 0)
		throw new Error("cannot compile: no files specified");
	var cwd = process.cwd;
	fstreamline__.invoke(flows, "each", [_, paths, fstreamline__.create(function(_, path) {
		fstreamline__.invoke(null, _compile_, [_, fspath.resolve(cwd, path), options], 0);
	}, 0)], 0);
	if (failed)
		throw new Error("errors found in " + failed + " files");
}, 0)

}, 0).call(this, function(err) {
  if (err) throw err;
}));