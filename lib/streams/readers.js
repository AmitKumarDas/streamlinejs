/*** Generated by streamline 0.1.36-stack - DO NOT EDIT ***/ "use strict"; var __global = typeof global !== 'undefined' ? global : window;__global.__setEF=__global.__setEF||function(e,f){e.__frame = e.__frame||f};var __srcName='streamline/lib/streams/readers_.js'; function __func(_, __this, __arguments, fn, index, frame, body) { if (!_) { return __future.call(__this, fn, __arguments, index); } frame.file = __srcName; frame.prev = __global.__frame; __global.__frame = frame; try { body(); } catch (e) { __global.__setEF(e, frame.prev); __propagate(_, e); } finally { __global.__frame = __frame.prev; } } function __cb(_, frame, offset, col, fn){ frame.offset = offset; frame.col = col; var ctx = __global.__context; return function ___(err, result){ var oldFrame = __global.__frame; __global.__frame = frame; __global.__context = ctx; try { if (err) { __global.__setEF(err, frame); return _(err); } return fn(null, result); } catch (ex) { __global.__setEF(ex, frame); return __propagate(_, ex); } finally { __global.__frame = oldFrame; } } } function __future(fn, args, i){ var done, err, result; var cb = function(e, r){ done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function ___(e, r){ cb(e, r); }; fn.apply(this, args); return function ___(_){ if (done) _.call(this, err, result); else cb = _.bind(this); } .bind(this); } function __nt(_, frame, fn){ var i = 0; var cb = __cb(_, frame, 0, 0, fn); if (typeof process != "undefined" && typeof process.nextTick == "function") return function ___(){ if (++i % 20 == 0) process.nextTick(cb); else cb(); }; else return function ___(){ if (++i % 20 == 0) setTimeout(cb, 0); else cb(); }; } function __propagate(_, err){ try { _(err); } catch (ex) { __trap(ex); } } function __trap(err){ if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } } var streams = require("./streams");
















exports.Reader = function(stream, boundary, options) {
 options = (options || { });
 options.defaultSize = (options.defaultSize || 512);
 if ((!stream.emitter && (typeof stream.on === "function"))) {

 stream = new streams.ReadableStream(stream, options);
 stream.setEncoding((options.encoding || "utf8")); };

 if (!boundary) {
 boundary = "\n"; };
 this.readItem = function readItem__1(_) { var chunks, len, chunk, i; var __frame = { name: "readItem__1", line: 28 }; return __func(_, this, arguments, readItem__1, 0, __frame, function __$readItem__1() {
 chunks = [];
 len = options.defaultSize; return (function ___(__break) { var __loop = __nt(_, __frame, function __$readItem__1() {
 var __2 = stream; if (__2) {
 return stream.read(__cb(_, __frame, 4, 15, function ___(__0, __1) { chunk = __1;
 if ((chunk == null)) {
 stream = null; }
 else {
 i = chunk.indexOf(boundary);
 if ((i >= 0)) {
 stream.unread(chunk.substring((i + boundary.length)));
 chunks.push(chunk.substring(0, i)); return __break(); } else {

 if ((chunk.length == (len + boundary.length))) {
 stream.unread(chunk.substring(len));
 chunks.push(chunk.substring(0, len)); }
 else {
 return _(new Error(((("missing boundary:" + boundary) + " in: ") + chunk))); } ; } ; } ; __loop(); }), (len + boundary.length)); } else { __break(); } ; }); __loop(); })(function __$readItem__1() {



 return _(null, ((chunks.length == 0) ? null : chunks.join(""))); }); }); };

 this.close = function close__2(_) { var __frame = { name: "close__2", line: 51 }; return __func(_, this, arguments, close__2, 0, __frame, function __$close__2() {
 stream = null; _(); }); };};