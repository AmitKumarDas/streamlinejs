/*** Generated by streamline 0.1.16 - DO NOT EDIT ***/

"use strict";
var __global = typeof global !== 'undefined' ? global : window;
function __cb(_, fn) { var ctx = __global.__context; return function(err, result) { __global.__context = ctx; if (err) return _(err); return fn(null, result); } }
function __future(fn, args, i) { var done, err, result; var cb = function(e, r) { done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function(e, r) { cb(e, r); }; fn.apply(this, args); return function(_) { if (done) _.call(this, err, result); else cb = _.bind(this); }.bind(this); }
function __nt(_, fn) { var i = 0; var cb = __cb(_, fn); var safeCb = function() { try { cb(); } catch (ex) { __propagate(cb, ex); } }; if (typeof process != "undefined" && typeof process.nextTick == "function") return function() { if (++i % 20 == 0) process.nextTick(safeCb); else cb(); }; else return function() { if (++i % 20 == 0) setTimeout(safeCb); else cb(); }; }
function __propagate(_, err) { try { _(err); } catch (ex) { __trap(ex); } }
function __trap(err) { if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } }
var parseUrl = require("url").parse;
function _reply(callback, err, value) {
  try {
    callback(err, value);
  } catch (ex) {
    __propagate(callback, ex);
  };
};
function checkOpen(stream) {
  if (!stream) {
    throw new Error("invalid operation on closed stream")
  };
};
function ReadableStream(stream, options) {
  options = (options || {
  });
  var _low = Math.max((options.lowMark || 0), 0);
  var _high = Math.max((options.highMark || 0), _low);
  var _paused = false;
  var _current = 0;
  var _chunks = [];
  var _error;
  var _done = false;
  var _encoding;
  var _chunk;
  stream.on("error", function __1(err) {
    _onData(err);
  });
  stream.on("data", function __2(chunk) {
    _onData(null, chunk);
  });
  stream.on("end", function __3() {
    _onData(null, null);
  });
  stream.on("close", function __4() {
    stream = null;
  });
  function trackData(err, chunk) {
    if (err) {
      _error = err;
    } else {
      if (chunk) {
        _chunks.push(chunk);
        _current += chunk.length;
        if (((((_current > _high) && !_paused) && !_done) && !_error)) {
          stream.pause();
          _paused = true;
        }
      ;
      }
       else _done = true;
    
    };
  };
  var _onData = trackData;
  function readChunk(callback) {
    if ((_chunks.length > 0)) {
      var chunk = _chunks.splice(0, 1)[0];
      _current -= chunk.length;
      if (((((_current <= _low) && _paused) && !_done) && !_error)) {
        stream.resume();
        _paused = false;
      }
    ;
      return _reply(callback, null, chunk);
    }
     else if (_done) {
      return _reply(callback, null, null);
    } else {
      if (_error) {
        return _reply(callback, _error);
      } else {
        _onData = function __1(err, chunk) {
          if (err) {
            _error = err;
          } else {
            if (!chunk) {
              _done = true;
            }
          };
          _onData = trackData;
          _reply(callback, err, chunk);
        };
      }
    }
  ;
  };
  function concat(chunks, total) {
    if (_encoding) {
      return chunks.join("")
    };
    if ((chunks.length == 1)) {
      return chunks[0]
    };
    var result = new Buffer(total);
    chunks.reduce(function __1(val, chunk) {
      chunk.copy(result, val);
      return (val + chunk.length);
    }, 0);
    return result;
  };
  this.setEncoding = function __5(enc) {
    checkOpen(stream);
    _encoding = enc;
    if (enc) {
      stream.setEncoding(enc);
    };
    return this;
  };
  this.read = function __6(_, len) {
    if (!_) {
      return __future(__6, arguments, 0);
    }
  ;
    var __then = _;
    if (!stream) {
      return _(null, null)
    };
    return function(__then) {
      if ((len == null)) {
        return readChunk(_);
      }
    ;
      return __then();
    }(function() {
      if ((len < 0)) {
        len = Infinity;
      };
      if ((len == 0)) {
        return _(null, (_encoding ? "" : new Buffer(0)))
      };
      var chunks = [], total = 0;
      return function(__break) {
        var __loop = __nt(_, function() {
          var __then = __loop;
          if ((total < len)) {
            return function(__then) {
              if (!_chunk) {
                return readChunk(__cb(_, function(__0, __2) {
                  _chunk = __2;
                  return __then();
                }));
              }
            ;
              return __then();
            }(function() {
              if (!_chunk) {
                return _(null, ((chunks.length == 0) ? null : concat(chunks, total)))
              };
              if (((total + _chunk.length) <= len)) {
                chunks.push(_chunk);
                total += _chunk.length;
                _chunk = null;
              }
               else {
                chunks.push(_chunk.slice(0, (len - total)));
                _chunk = _chunk.slice((len - total));
                total = len;
              }
            ;
              return __then();
            });
          }
           else {
            return __break();
          }
        ;
        });
        return __loop();
      }(function() {
        return _(null, concat(chunks, total));
      });
    });
  };
  this.readAll = function __7(_) {
    if (!_) {
      return __future.call(this, __7, arguments, 0);
    }
  ;
    var __then = _;
    return this.read(_, -1);
  };
  this.__defineGetter__("stream", function __8() {
    return stream;
  });
};
function WritableStream(stream, options) {
  options = (options || {
  });
  stream.on("close", function __1() {
    stream = null;
  });
  this.write = function __2(data, enc) {
    checkOpen(stream);
    stream.write(data, enc);
    return this;
  };
  this.end = function __3(data, enc) {
    checkOpen(stream);
    stream.end(data, enc);
    return this;
  };
  this.__defineGetter__("stream", function __4() {
    return stream;
  });
};
function ServerRequestWrapper(req, options) {
  ReadableStream.call(this, req, options);
  this._request = req;
  this.setEncoding(_getEncoding(req.headers));
};
["method","url","headers","trailers","httpVersion","connection","socket",].forEach(function __1(name) {
  ServerRequestWrapper.prototype.__defineGetter__(name, function __1() {
    return this._request[name];
  });
});
exports.httpServerRequest = function __2(req, options) {
  return new ServerRequestWrapper(req, options);
};
function _getEncoding(headers) {
  var comps = ((headers["content-type"] || "text/plain")).split(";");
  var ctype = comps[0];
  for (var i = 1; (i < comps.length); i++) {
    var pair = comps[i].split("=");
    if (((pair.length == 2) && (pair[0].trim() == "charset"))) {
      return pair[1].trim()
    };
  };
  if (((ctype.indexOf("text") >= 0) || (ctype.indexOf("json") >= 0))) {
    return "utf8"
  };
  return null;
};
function ClientResponseWrapper(resp, options) {
  ReadableStream.call(this, resp, options);
  this._response = resp;
  this.setEncoding(_getEncoding(resp.headers));
};
["statusCode","headers",].forEach(function __3(name) {
  ClientResponseWrapper.prototype.__defineGetter__(name, function __1() {
    return this._response[name];
  });
});
ClientResponseWrapper.prototype.checkStatus = function __4(statuses) {
  if ((typeof statuses === "number")) {
    statuses = [statuses,];
  };
  if ((statuses.indexOf(this.statusCode) < 0)) {
    throw new Error(("invalid status: " + this.statusCode))
  };
  return this;
};
function _fixOptions(options) {
  if (!options) {
    throw new Error("request error: no options")
  };
  if ((typeof options === "string")) {
    options = {
      url: options
    };
  };
  if (options.url) {
    var parsed = parseUrl(options.url);
    options.protocol = parsed.protocol;
    options.host = parsed.hostname;
    options.port = parsed.port;
    options.path = (parsed.pathname + ((parsed.query ? ("?" + parsed.query) : "")));
  }
;
  options.protocol = (options.protocol || "http:");
  options.port = (options.port || (((options.protocol === "https:") ? 443 : 80)));
  options.path = (options.path || "/");
  if (!options.host) {
    throw new Error("request error: no host")
  };
  options.method = (options.method || "GET");
  options.headers = (options.headers || {
  });
  options.module = require(options.protocol.substring(0, (options.protocol.length - 1)));
  if (options.proxy) {
    if ((typeof options.proxy === "string")) {
      options.proxy = parseUrl(options.proxy);
      options.proxy.host = options.proxy.hostname;
    }
  ;
    options.proxy.port = (options.proxy.port || options.port);
    if (!options.proxy.host) {
      throw new Error("proxy configuration error: no host")
    };
    options.path = (((((options.protocol + "//") + options.host) + ":") + options.port) + options.path);
    options.headers.host = options.host;
    options.host = options.proxy.host;
    options.port = options.proxy.port;
  }
;
  return options;
};
function ClientRequestWrapper(options) {
  options = _fixOptions(options);
  var _request = options.module.request(options, function __1(resp) {
    _onResponse(null, (resp && new ClientResponseWrapper(resp, options)));
  });
  WritableStream.call(this, _request, options);
  var _response;
  var _error;
  var _done = false;
  _request.on("error", function __2(err) {
    _onResponse(err);
  });
  function trackResponse(err, resp) {
    _done = true;
    _error = err;
    _response = resp;
  };
  var _onResponse = trackResponse;
  this.response = function __3(callback) {
    if (!callback) {
      return __future.call(this, this.response, arguments, 0)
    };
    if (_done) {
      return _reply(callback, _error, _response);
    } else {
      _onResponse = function __1(err, resp) {
        _reply(callback, err, resp);
      };
    };
  };
};
exports.httpRequest = function __5(options) {
  return new ClientRequestWrapper(options);
};
function NetStream(stream, options) {
  ReadableStream.call(this, stream, (options.read || options));
  WritableStream.call(this, stream, (options.write || options));
};
var net;
function NetClient(options, args) {
  args = Array.prototype.slice.call(arguments, 1);
  net = (net || require("net"));
  var _connection = net.createConnection.apply(net, args);
  var _error;
  var _done = false;
  _connection.on("error", function __1(err) {
    console.error("ERROR");
    _onConnect(err);
  });
  _connection.on("connect", function __2() {
    console.error("CONNECTED:");
    _onConnect(null);
  });
  function trackConnect(err) {
    _done = true;
    _error = err;
  };
  var _onConnect = trackConnect;
  this.connect = function __3(callback) {
    if (!callback) {
      return __future.call(this, this.connect, arguments, 0)
    };
    if (_done) {
      return _reply(callback, _error, new NetStream(_connection, options));
    } else {
      _onConnect = function __1(err) {
        _reply(callback, err, new NetStream(_connection, options));
      };
    };
  };
};
exports.tcpClient = function __6(port, host, options) {
  host = (host || "localhost");
  options = (options || {
  });
  return new NetClient(options, port, host);
};
exports.socketClient = function __7(path, options) {
  options = (options || {
  });
  return new NetClient(options, path);
};