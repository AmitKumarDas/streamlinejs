/*** Generated by streamline 0.1.16 - DO NOT EDIT ***/

"use strict";
var __global = typeof global !== 'undefined' ? global : window;
function __cb(_, fn) { var ctx = __global.__context; return function(err, result) { __global.__context = ctx; if (err) return _(err); return fn(null, result); } }
function __future(fn, args, i) { var done, err, result; var cb = function(e, r) { done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function(e, r) { cb(e, r); }; fn.apply(this, args); return function(_) { if (done) _.call(this, err, result); else cb = _.bind(this); }.bind(this); }
function __nt(_, fn) { var i = 0; var cb = __cb(_, fn); var safeCb = function() { try { cb(); } catch (ex) { __propagate(cb, ex); } }; if (typeof process != "undefined" && typeof process.nextTick == "function") return function() { if (++i % 20 == 0) process.nextTick(safeCb); else cb(); }; else return function() { if (++i % 20 == 0) setTimeout(safeCb); else cb(); }; }
function __propagate(_, err) { try { _(err); } catch (ex) { __trap(ex); } }
function __trap(err) { if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } }
var parseUrl = require("url").parse;
function _reply(callback, err, value) {
  try {
    callback(err, value);
  } catch (ex) {
    __propagate(callback, ex);
  };
};
function InputStreamWrapper(stream, options) {
  options = (options || {
  });
  var lowMark = Math.max((options.lowMark || 0), 0);
  var highMark = Math.max((options.highMark || 0), lowMark);
  var paused = false;
  var current = 0;
  var chunks = [];
  var error;
  var done = false;
  stream.on("error", function __1(err) {
    onEvent(err);
  });
  stream.on("data", function __2(chunk) {
    onEvent(null, chunk);
  });
  stream.on("end", function __3() {
    onEvent(null, null);
  });
  var trackEvent = function __4(err, chunk) {
    if (err) {
      error = err;
    } else {
      if (chunk) {
        chunks.push(chunk);
        current += chunk.length;
        if (((current > highMark) && !paused)) {
          stream.pause();
          paused = true;
        }
      ;
      }
       else done = true;
    
    };
  };
  var onEvent = trackEvent;
  this.read = function read(callback) {
    if (!callback) {
      return __future.call(this, read, arguments, 0)
    };
    if ((chunks.length > 0)) {
      var chunk = chunks.splice(0, 1)[0];
      current -= chunk.length;
      if (((current <= lowMark) && paused)) {
        stream.resume();
        paused = false;
      }
    ;
      return _reply(callback, null, chunk);
    }
     else if (done) {
      return _reply(callback, null, null);
    } else {
      if (error) {
        return _reply(callback, error);
      } else {
        onEvent = function __1(err, chunk) {
          onEvent = trackEvent;
          _reply(callback, err, chunk);
        };
      }
    }
  ;
  };
  function concat(chunks, total) {
    if ((false && (chunks[0] instanceof Buffer))) {
      var result = new Buffer(total);
      chunks.reduce(function __1(val, chunk) {
        chunk.copy(result, val, 0);
        return (val + chunk.length);
      }, 0);
      return result;
    }
     else return chunks.join("")
  ;
  };
  this.readAll = function __5(_) {
    if (!_) {
      return __future.call(this, __5, arguments, 0);
    }
  ;
    var __then = _;
    var chunk, chunks = [], total = 0;
    return function(__break) {
      var __loop = __nt(_, function() {
        var __then = __loop;
        return this.read(__cb(_, function(__0, __1) {
          if (chunk = __1) {
            chunks.push(chunk);
            total += chunks.length;
          }
           else {
            return __break();
          }
        ;
          return __then();
        }.bind(this)));
      }.bind(this));
      return __loop();
    }.call(this, function() {
      return _(null, concat(chunks, total));
    }.bind(this));
  };
};
function ServerRequestWrapper(req, options) {
  InputStreamWrapper.call(this, req, options);
  this._req = req;
};
["method","url","headers","trailers","httpVersion","connection","socket",].forEach(function __1(name) {
  ServerRequestWrapper.prototype.__defineGetter__(name, function __1() {
    return this._req[name];
  });
});
exports.httpServerRequest = function __2(req, options) {
  return new ServerRequestWrapper(req, options);
};
function ClientResponseWrapper(resp, options) {
  InputStreamWrapper.call(this, resp, options);
  this._resp = resp;
};
["statusCode","headers",].forEach(function __3(name) {
  ClientResponseWrapper.prototype.__defineGetter__(name, function __1() {
    return this._resp[name];
  });
});
ClientResponseWrapper.prototype.checkStatus = function __4(statuses) {
  if ((typeof statuses === "number")) {
    statuses = [statuses,];
  };
  if ((statuses.indexOf(this.statusCode) < 0)) {
    throw new Error(("invalid status: " + this.statusCode))
  };
  return this;
};
function _fixOptions(options) {
  if (!options) {
    throw new Error("request error: no options")
  };
  if ((typeof options === "string")) {
    options = {
      url: options
    };
  };
  if (options.url) {
    var parsed = parseUrl(options.url);
    options.protocol = parsed.protocol;
    options.host = parsed.hostname;
    options.port = parsed.port;
    options.path = (parsed.pathname + ((parsed.query ? ("?" + parsed.query) : "")));
  }
;
  options.protocol = (options.protocol || "http:");
  options.port = (options.port || (((options.protocol === "https:") ? 443 : 80)));
  options.path = (options.path || "/");
  if (!options.host) {
    throw new Error("request error: no host")
  };
  options.method = (options.method || "GET");
  options.headers = (options.headers || {
  });
  options.module = require(options.protocol.substring(0, (options.protocol.length - 1)));
  if ((options.protocol === "https:")) {
    options.proxy = ((options.proxy || process.env.https_proxy) || process.env.HTTPS_PROXY);
  };
  options.proxy = ((options.proxy || process.env.http_proxy) || process.env.HTTP_PROXY);
  if (options.proxy) {
    if ((typeof options.proxy === "string")) {
      options.proxy = parseUrl(options.proxy);
      options.proxy.host = options.proxy.hostname;
    }
  ;
    options.proxy.port = (options.proxy.port || options.port);
    if (!options.proxy.host) {
      throw new Error("proxy configuration error: no host")
    };
    options.path = (((((options.protocol + "//") + options.host) + ":") + options.port) + options.path);
    options.headers.host = options.host;
    options.host = options.proxy.host;
    options.port = options.proxy.port;
  }
;
  return options;
};
function ClientRequestWrapper(options) {
  options = _fixOptions(options);
  var req = options.module.request(options, function __1(resp) {
    onEvent(null, (resp && new ClientResponseWrapper(resp, options)));
  });
  var response;
  var error;
  var done = false;
  req.on("error", function __2(err) {
    onEvent(err);
  });
  var trackEvent = function __3(err, resp) {
    done = true;
    error = err;
    response = resp;
  };
  var onEvent = trackEvent;
  this.write = function __4(data, enc) {
    req.write(data, enc);
    return this;
  };
  this.end = function __5(data, enc) {
    req.end(data, enc);
    return this;
  };
  this.response = function response(callback) {
    if (!callback) {
      return __future.call(this, response, arguments, 0)
    };
    if (done) {
      return _reply(callback, error, response);
    } else {
      onEvent = function __1(err, resp) {
        _reply(callback, err, resp);
      };
    };
  };
};
exports.httpRequest = function __5(options) {
  return new ClientRequestWrapper(options);
};