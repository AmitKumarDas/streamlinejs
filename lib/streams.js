/*** Generated by streamline 0.1.16 - DO NOT EDIT ***/

"use strict";
var __global = typeof global !== 'undefined' ? global : window;
function __cb(_, fn) { var ctx = __global.__context; return function(err, result) { __global.__context = ctx; if (err) return _(err); return fn(null, result); } }
function __future(fn, args, i) { var done, err, result; var cb = function(e, r) { done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function(e, r) { cb(e, r); }; fn.apply(this, args); return function(_) { if (done) _.call(this, err, result); else cb = _.bind(this); }.bind(this); }
function __nt(_, fn) { var i = 0; var cb = __cb(_, fn); var safeCb = function() { try { cb(); } catch (ex) { __propagate(cb, ex); } }; if (typeof process != "undefined" && typeof process.nextTick == "function") return function() { if (++i % 20 == 0) process.nextTick(safeCb); else cb(); }; else return function() { if (++i % 20 == 0) setTimeout(safeCb); else cb(); }; }
function __propagate(_, err) { try { _(err); } catch (ex) { __trap(ex); } }
function __trap(err) { if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } }
var http = require("http");
function _reply(callback, err, value) {
  try {
    callback(err, value);
  } catch (ex) {
    __propagate(callback, ex);
  };
};
function InputStreamWrapper(stream, options) {
  options = (options || {
  });
  var lowMark = Math.max((options.lowMark || 0), 0);
  var highMark = Math.max((options.highMark || 0), lowMark);
  var paused = false;
  var current = 0;
  var chunks = [];
  var error;
  var done = false;
  stream.on("error", function __1(err) {
    onEvent(err);
  });
  stream.on("data", function __2(chunk) {
    onEvent(null, chunk);
  });
  stream.on("end", function __3() {
    onEvent(null, null);
  });
  var trackEvent = function __4(err, chunk) {
    if (err) {
      error = err;
    } else {
      if (chunk) {
        chunks.push(chunk);
        current += chunk.length;
        if (((current > highMark) && !paused)) {
          stream.pause();
          paused = true;
        }
      ;
      }
       else done = true;
    
    };
  };
  var onEvent = trackEvent;
  this.read = function read(callback) {
    if (!callback) {
      return __future.call(this, read, arguments, 0)
    };
    if ((chunks.length > 0)) {
      var chunk = chunks.splice(0, 1)[0];
      current -= chunk.length;
      if (((current <= lowMark) && paused)) {
        stream.resume();
        paused = false;
      }
    ;
      return _reply(callback, null, chunk);
    }
     else if (done) {
      return _reply(callback, null, null);
    } else {
      if (error) {
        return _reply(callback, error);
      } else {
        onEvent = function __1(err, chunk) {
          onEvent = trackEvent;
          _reply(callback, err, chunk);
        };
      }
    }
  ;
  };
  this.readAll = function __5(_) {
    if (!_) {
      return __future.call(this, __5, arguments, 0);
    }
  ;
    var __then = _;
    var chunk, chunks = [];
    return function(__break) {
      var __loop = __nt(_, function() {
        var __then = __loop;
        return this.read(__cb(_, function(__0, __1) {
          if (chunk = __1) {
            chunks.push(chunk);
          }
           else {
            return __break();
          }
        ;
          return __then();
        }.bind(this)));
      }.bind(this));
      return __loop();
    }.call(this, function() {
      return _(null, chunks.join(""));
    }.bind(this));
  };
};
function ServerRequestWrapper(req, options) {
  InputStreamWrapper.call(this, req, options);
  this._req = req;
};
["method","url","headers","trailers","httpVersion","connection","socket",].forEach(function __1(name) {
  ServerRequestWrapper.prototype.__defineGetter__(name, function __1() {
    return this._req[name];
  });
});
exports.httpServerRequest = function __2(req, options) {
  return new ServerRequestWrapper(req, options);
};
function ClientResponseWrapper(resp, options) {
  InputStreamWrapper.call(this, resp, options);
  this._resp = resp;
};
["statusCode","headers",].forEach(function __3(name) {
  ClientResponseWrapper.prototype.__defineGetter__(name, function __1() {
    return this._resp[name];
  });
});
ClientResponseWrapper.prototype.checkStatus = function __4(statuses) {
  if ((typeof statuses === "number")) {
    statuses = [statuses,];
  };
  if ((statuses.indexOf(this.statusCode) < 0)) {
    throw new Error(("invalid status: " + this.statusCode))
  };
  return this;
};
function ClientRequestWrapper(options) {
  var req = http.request(options, function __1(resp) {
    onEvent(null, (resp && new ClientResponseWrapper(resp, options)));
  });
  var response;
  var error;
  var done = false;
  req.on("error", function __2(err) {
    onEvent(err);
  });
  var trackEvent = function __3(err, resp) {
    done = true;
    error = err;
    response = resp;
  };
  var onEvent = trackEvent;
  this.write = function __4(data, enc) {
    req.write(data, enc);
    return this;
  };
  this.end = function __5(data, enc) {
    req.end(data, enc);
    return this;
  };
  this.response = function response(callback) {
    if (!callback) {
      return __future.call(this, response, arguments, 0)
    };
    if (done) {
      return _reply(callback, error, response);
    } else {
      onEvent = function __1(err, resp) {
        _reply(callback, err, resp);
      };
    };
  };
};
exports.httpRequest = function __5(options) {
  return new ClientRequestWrapper(options);
};