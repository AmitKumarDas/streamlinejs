/*** Generated by streamline 0.1.22 - DO NOT EDIT ***/
 "use strict"; var __global = typeof global !== 'undefined' ? global : window; function __cb(_, fn) { var ctx = __global.__context; return function(err, result) { __global.__context = ctx; if (err) return _(err); try { return fn(null, result); } catch (ex) { return __propagate(_, ex); } } } function __future(fn, args, i) { var done, err, result; var cb = function(e, r) { done = true; err = e, result = r; }; args = Array.prototype.slice.call(args); args[i] = function(e, r) { cb(e, r); }; fn.apply(this, args); return function(_) { if (done) _.call(this, err, result); else cb = _.bind(this); }.bind(this); } function __nt(_, fn) { var i = 0; var cb = __cb(_, fn); var safeCb = function() { try { cb(); } catch (ex) { __propagate(cb, ex); } }; if (typeof process != "undefined" && typeof process.nextTick == "function") return function() { if (++i % 20 == 0) process.nextTick(safeCb); else cb(); }; else return function() { if (++i % 20 == 0) setTimeout(safeCb); else cb(); }; } function __propagate(_, err) { try { _(err); } catch (ex) { __trap(ex); } } function __trap(err) { if (err) { if (__global.__context && __global.__context.errorHandler) __global.__context.errorHandler(err); else console.error("UNCAUGHT EXCEPTION: " + err.message + "\n" + err.stack); } } var streams = require("streamline/lib/streams/streams");


var module = QUnit.module;

var bufSize = 100;
var bufCount = 3;
var totalSize = (bufCount * bufSize);
var modulo = 17;

function makeBuffer(i) {
 var buf = new Buffer(bufSize);
 for (var j = 0; (j < bufSize); j++) { buf[j] = ((48 + i) + ((j % modulo)));; };


 return buf;};


function checkBuffer(buf, start) {
 ok((buf != null), "buffer not null");
 var i = Math.floor((start / bufSize));
 var j = (start % bufSize);
 for (var k = 0; (k < buf.length); k++, j++) {
 if ((j == bufSize)) {
 i++;
 j = 0; } ;

 if ((buf[k] !== ((48 + i) + ((j % modulo))))) {
 return ok(false, ((((((("buffer verification failed:  i=" + i) + ", j=") + j) + " k=") + k) + " val=") + buf[k])) }; };

 ok(true, "buffer content is valid");
 return (start + buf.length);};


new streams.HttpServer(function __1(req, res, _) { if (!_) { return __future(__1, arguments, 2); }; var __then = _;
 res.writeHead(200, { "Content-Type": "application/octet-stream" });
 res.emitter.on("drain", function __1() {
 process.stderr.write("*"); });

 var i = 0; var __4 = false; return function(__break) { var __loop = __nt(_, function() { var __then = __loop; if (__4) { i++; } else { __4 = true; } ; if ((i < bufCount)) {
 return res.write(__cb(_, function() {
 return process.nextTick(__cb(_, __then)); }), makeBuffer(i)); } else { return __break(); } ; }); return __loop(); }(function() {

 res.end(); return __then(); });
}).listen(null, 1337, "127.0.0.1");


var paused = 0, resumed = 0;
var doStop = false;

module("node streams test", {
 setup: function __2() {  },

 teardown: function __3() {
 if (doStop) {

 setTimeout(function __1() {
 process.kill(process.pid);
 }, 0); } ; }});




function addBufferHooks(stream) {
 var pause = stream.pause.bind(stream);
 stream.pause = function __1() {

 paused++;
 pause(); };

 var resume = stream.resume.bind(stream);
 stream.resume = function __2() {

 resumed++;
 resume(); };};



function doTest(_, name, options, fn) { if (!_) { return __future(doTest, arguments, 0); }; var __then = _;

 options.url = "http://127.0.0.1:1337/";
 return streams.httpRequest(options).end().response(__cb(_, function(__0, resp) {
 addBufferHooks(resp.emitter);
 return fn(__cb(_, function() {
 return resp.read(__cb(_, function(__0, last) {
 strictEqual(last, null, "read return null at end"); return __then(); })); }), resp); }));};



function dot(_) { if (!_) { return __future(dot, arguments, 0); }; var __then = _;
 return process.nextTick(__cb(_, __then));};




function testPass(name, options) {

 var t0 = Date.now();

 function testRead(name, detail, size) {
 asyncTest(((name + " / ") + detail), function __1(_) { if (!_) { return __future(__1, arguments, 0); } ; var __then = _;
 return doTest(__cb(_, function() {







 start(); return __then(); }), name, options, function __1(_, resp) { if (!_) { return __future(__1, arguments, 0); } ; var __then = _; var i = 0, total = 0; var __2 = false; return function(__break) { var __loop = __nt(_, function() { var __then = __loop; if (__2) { i++; } else { __2 = true; } ; if ((total < totalSize)) { var len = ((size && (typeof size === "function")) ? size() : size); return resp.read(__cb(_, function(__0, buf) { total = checkBuffer(buf, total); return __then(); }), len); } else { return __break(); } ; }); return __loop(); }(__then); }); }); };



 testRead(name, "chunk read");
 testRead(name, "half size read", Math.floor((bufSize / 2)));
 testRead(name, "double size read", (bufSize * 2));
 testRead(name, "odd size read", Math.floor(((4 * bufSize) / 7)));
 (false && testRead(name, "random size read", function __1() {
 var r = Math.random();
 return Math.floor((((((r * r) * r) * r) * 3) * bufSize)); }));};




var oneTenth = Math.floor(((bufCount * bufSize) / 10));

testPass("default buffering", {});
testPass("buffer 0/1 tenth", { lowMark: 0, highMark: oneTenth});
testPass("buffer 2/3 tenth", { lowMark: (2 * oneTenth), highMark: (3 * oneTenth)});
testPass("buffer 1 tenth and above", { lowMark: oneTenth, highMark: (11 * oneTenth)});
testPass("buffer all", { lowMark: 0, highMark: (11 * oneTenth)});

asyncTest("stop  tests", 0, function __4(_) { if (!_) { return __future(__4, arguments, 0); }; var __then = _;
 doStop = true;
 start(); return __then();});